import { $ } from "bun";
import { createAgentTask, normalizeBwrbNoteRef, resolveAgentTaskByIssue } from "./queue-backend";
import type { TaskPriority } from "./queue/priority";
import { hasIdempotencyKey, recordIdempotencyKey } from "./state";
import { sanitizeNoteName } from "./util/sanitize-note-name";
import { appendBwrbNoteBody, buildEscalationPayload, buildIdeaPayload, createBwrbNote } from "./bwrb/artifacts";
import { recordIssueErrorAlert, recordRepoErrorAlert, recordRollupReadyAlert } from "./alerts/service";
import { parseIssueRef } from "./github/issue-ref";

const sanitizeNoteTitle = sanitizeNoteName;

export type NotificationType = "escalation" | "rollup-ready" | "error" | "task-complete";

export type ErrorNotificationContext = {
  repo?: string | null;
  issue?: string | null;
  taskName?: string | null;
};

type ErrorNotificationInput = ErrorNotificationContext | string | null | undefined;

// Cache for terminal-notifier availability check
let terminalNotifierAvailable: boolean | null = null;

/**
 * Check if terminal-notifier is installed on the system.
 * Result is cached for the lifetime of the process.
 */
async function isTerminalNotifierAvailable(): Promise<boolean> {
  if (terminalNotifierAvailable !== null) {
    return terminalNotifierAvailable;
  }

  try {
    await $`which terminal-notifier`.quiet();
    terminalNotifierAvailable = true;
    console.log("[ralph:notify] terminal-notifier is available");
  } catch {
    terminalNotifierAvailable = false;
    console.log("[ralph:notify] terminal-notifier not found, desktop notifications disabled");
  }

  return terminalNotifierAvailable;
}

/**
 * Send a desktop notification using terminal-notifier (macOS).
 * Falls back silently if terminal-notifier is not installed.
 */
async function sendDesktopNotification(opts: {
  title: string;
  subtitle?: string;
  message: string;
  openUrl?: string;
  sound?: string;
}): Promise<boolean> {
  if (!(await isTerminalNotifierAvailable())) {
    return false;
  }

  try {
    const args: string[] = [
      "-title", opts.title,
      "-message", opts.message,
    ];

    if (opts.subtitle) {
      args.push("-subtitle", opts.subtitle);
    }

    if (opts.openUrl) {
      args.push("-open", opts.openUrl);
    }

    if (opts.sound) {
      args.push("-sound", opts.sound);
    }

    await $`terminal-notifier ${args}`.quiet();
    return true;
  } catch (e) {
    console.warn("[ralph:notify] Failed to send desktop notification:", e);
    return false;
  }
}

function getNotificationPrefix(type: NotificationType): string {
  switch (type) {
    case "escalation":
      return "[ESCALATION]";
    case "rollup-ready":
      return "[ROLLUP READY]";
    case "error":
      return "[ERROR]";
    case "task-complete":
      return "[COMPLETE]";
    default:
      return "[RALPH]";
  }
}

/**
 * Create a notification as a bwrb idea note.
 */
async function createNotification(
  type: NotificationType,
  title: string,
  body: string,
  relatedTask?: string
): Promise<boolean> {
  const today = new Date().toISOString().split("T")[0];
  const prefix = getNotificationPrefix(type);

  const noteBody = [
    `## ${type.replace("-", " ").toUpperCase()}`,
    "",
    body,
    "",
    relatedTask ? `**Related Task:** [[${relatedTask}]]` : "",
    "",
    `*Generated by Ralph Loop at ${new Date().toISOString()}*`,
    "",
  ]
    .filter(Boolean)
    .join("\n");

  const baseTitle = sanitizeNoteName(`${prefix} ${title}`);

  const payload = buildIdeaPayload({
    name: baseTitle,
    creationDate: today,
    scope: "builder",
  });

  const output = await createBwrbNote({
    type: "idea",
    action: "create notification",
    payload,
    allowDuplicateSuffix: true,
  });

  if (!output.ok || !output.path) {
    const error = output.ok ? "bwrb did not return a note path" : output.error;
    const log = !output.ok && output.skipped ? console.warn : console.error;
    log(`[ralph:notify] Failed to create notification: ${error}`);
    return false;
  }

  const bodyResult = await appendBwrbNoteBody({ notePath: output.path, body: noteBody });
  if (!bodyResult.ok) {
    const log = bodyResult.skipped ? console.warn : console.error;
    log(`[ralph:notify] Failed to write notification body: ${bodyResult.error}`);
    return false;
  }

  console.log(`[ralph:notify] Created notification: ${baseTitle}`);
  return true;
}

export interface EscalationContext {
  /** The display name of the task (from frontmatter `name` field) */
  taskName: string;
  /** The filename without extension (from bwrb `_name` field) - used for wikilinks */
  taskFileName: string;
  /** The full path to the task note (from bwrb `_path` field) */
  taskPath: string;
  issue: string;
  repo: string;
  /** The original task scope (if known) */
  scope?: string;
  /** The original task priority (if known) */
  priority?: TaskPriority;
  /** OpenCode session ID (for resuming after resolution) */
  sessionId?: string;
  reason: string;
  escalationType: "product-gap" | "low-confidence" | "ambiguous-requirements" | "blocked" | "other";
  planOutput?: string;
  githubCommentUrl?: string;
  routing?: {
    decision: string;
    confidence?: string | null;
    escalation_reason?: string | null;
    plan_summary?: string | null;
  };
  devex?: {
    consulted: boolean;
    sessionId?: string;
    summary?: string;
  };
}

/**
 * Extract the @product consultation section from agent output.
 * Looks for patterns like "**Product context (@product)**" followed by content.
 */
function extractProductConsultation(output: string): string | null {
  // Look for product agent output patterns - capture until next ## heading or end
  const patterns = [
    // ## Product Review section
    /## Product Review\s*\n([\s\S]*?)(?=\n##|$)/i,
    // **Product context (@product)** followed by content until next ## or routing decision
    /\*\*Product[^*]*\*\*[:\s]*([\s\S]*?)(?=\n##|\n\*\*Routing|\{"decision"|$)/i,
    // @product subagent output
    /@product[^:]*:\s*([\s\S]*?)(?=\n##|\n@|$)/i,
  ];

  for (const pattern of patterns) {
    const match = output.match(pattern);
    if (match && match[1]?.trim()) {
      return match[1].trim();
    }
  }
  return null;
}

/**
 * Extract implementation plan summary from agent output.
 */
function extractPlanSummary(output: string): string | null {
  const patterns = [
    // ## Implementation Plan section - capture content after heading
    /## Implementation Plan\s*\n([\s\S]*?)(?=\n##|$)/i,
    // ## Plan section
    /## Plan\s*\n([\s\S]*?)(?=\n##|$)/i,
    // **Plan** inline format
    /\*\*Plan[^*]*\*\*[:\s]*([\s\S]*?)(?=\n##|\n\*\*Routing|\{"decision"|$)/i,
  ];

  for (const pattern of patterns) {
    const match = output.match(pattern);
    if (match && match[1]?.trim()) {
      return match[1].trim();
    }
  }
  return null;
}

function sanitizeDiagnostics(text: string): string {
  // Strip ANSI escape codes.
  let out = text.replace(/\x1b\[[0-9;]*m/g, "");

  // Best-effort redaction (keep conservative, avoid overfitting).
  const patterns: Array<{ re: RegExp; replacement: string }> = [
    { re: /ghp_[A-Za-z0-9]{20,}/g, replacement: "ghp_[REDACTED]" },
    { re: /github_pat_[A-Za-z0-9_]{20,}/g, replacement: "github_pat_[REDACTED]" },
    { re: /sk-[A-Za-z0-9]{20,}/g, replacement: "sk-[REDACTED]" },
    { re: /xox[baprs]-[A-Za-z0-9-]{10,}/g, replacement: "xox-[REDACTED]" },
    { re: /(Bearer\s+)[A-Za-z0-9._-]+/gi, replacement: "$1[REDACTED]" },
    { re: /(Authorization:\s*Bearer\s+)[A-Za-z0-9._-]+/gi, replacement: "$1[REDACTED]" },
  ];

  for (const { re, replacement } of patterns) {
    out = out.replace(re, replacement);
  }

  return out;
}

export async function notifyEscalation(ctx: EscalationContext): Promise<boolean> {
  const today = new Date().toISOString().split("T")[0];
  const shortIssue = ctx.issue.split("/").pop() || ctx.issue;

  // Defensive normalization: bwrb identifiers can include accidental newlines/whitespace.
  const attemptedTaskPath = normalizeBwrbNoteRef(ctx.taskPath);
  const attemptedTaskFileName = normalizeBwrbNoteRef(ctx.taskFileName);

  let resolvedTaskPath = attemptedTaskPath;
  let resolvedTaskFileName = attemptedTaskFileName;
  let createdReplacementTask = false;

  // Ensure the task exists before creating an escalation.
  // If it can't be resolved (e.g. task note renamed/moved/deleted), create a replacement agent-task.
  const resolved = await resolveAgentTaskByIssue(ctx.issue, ctx.repo);
  if (resolved) {
    resolvedTaskPath = resolved._path;
    resolvedTaskFileName = resolved._name;

    if (attemptedTaskPath && attemptedTaskPath !== resolvedTaskPath) {
      console.warn(
        `[ralph:notify] Escalation task path was stale; resolved by issue (${ctx.issue}): ${attemptedTaskPath} -> ${resolvedTaskPath}`
      );
    }
  } else {
    console.warn(`[ralph:notify] Task not found for escalation (issue=${ctx.issue}); creating replacement agent-task...`);

    const replacement = await createAgentTask({
      name: sanitizeNoteTitle(`Recovered Task - ${shortIssue} - ${ctx.taskName}`),
      issue: ctx.issue,
      repo: ctx.repo,
      scope: ctx.scope ?? "builder",
      status: "escalated",
      ...(ctx.priority ? { priority: ctx.priority } : {}),
    });

    if (!replacement) {
      const msg = `Failed to create replacement agent-task for ${ctx.issue}; cannot create required agent-escalation.task relation.`;
      console.error(`[ralph:notify] ${msg}`);

      // Last-resort operator-visible artifact (does not change bwrb schema).
      await createNotification(
        "error",
        `Escalation creation failed for ${shortIssue}`,
        `${msg}\n\nAttempted task path: ${attemptedTaskPath || "(none)"}\nAttempted task file: ${attemptedTaskFileName || "(none)"}\nSession: ${ctx.sessionId ?? ""}`
      );

      return false;
    }

    createdReplacementTask = true;
    resolvedTaskPath = replacement.taskPath;
    resolvedTaskFileName = replacement.taskFileName;

    console.warn(
      `[ralph:notify] Created replacement agent-task for ${ctx.issue}: ${resolvedTaskPath} (file=${resolvedTaskFileName})`
    );
  }

  const idempotencyKey = [
    "notifyEscalation",
    ctx.issue,
    resolvedTaskPath,
    ctx.sessionId ?? "",
    ctx.escalationType,
  ].join(":");

  try {
    if (hasIdempotencyKey(idempotencyKey)) {
      console.warn(`[ralph:notify] Escalation already recorded (idempotency); skipping duplicate: ${idempotencyKey}`);
      return true;
    }
  } catch {
    // best-effort
  }

  // Build the note body with rich context
  const bodyParts: string[] = [
    `## Escalation Summary`,
    "",
    `Task **${ctx.taskName}** requires your attention.`,
    "",
    `| Field | Value |`,
    `|-------|-------|`,
    `| Issue | ${ctx.issue} |`,
    ...(ctx.githubCommentUrl ? [`| GitHub Comment | ${ctx.githubCommentUrl} |`] : []),
    `| Repo | ${ctx.repo} |`,
    `| Type | ${ctx.escalationType} |`,
    `| Reason | ${ctx.reason} |`,
    "",
  ];

  bodyParts.push(
    `## Task Note Resolution`,
    "",
    `- Attempted task path: ${attemptedTaskPath || "(none)"}`,
    `- Resolved task path: ${resolvedTaskPath || "(none)"}`,
    `- Attempted task file: ${attemptedTaskFileName || "(none)"}`,
    `- Resolved task file: ${resolvedTaskFileName || "(none)"}`,
    `- Replacement task created: ${createdReplacementTask ? "yes" : "no"}`,
    ""
  );

  // Add routing decision if available
  if (ctx.routing) {
    bodyParts.push(
      `## Routing Decision`,
      "",
      `- **Decision:** ${ctx.routing.decision}`,
      ctx.routing.confidence ? `- **Confidence:** ${ctx.routing.confidence}` : "",
      ctx.routing.plan_summary ? `- **Plan Summary:** ${ctx.routing.plan_summary}` : "",
      ""
    );
  }

  // Add devex consultation if provided
  if (ctx.devex?.consulted) {
    bodyParts.push(
      `## Devex Consult`,
      "",
      ctx.devex.sessionId ? `- **Session:** ${ctx.devex.sessionId}` : "",
      ctx.devex.summary ? ctx.devex.summary : "(Devex consulted; no summary captured)",
      ""
    );
  }

  // Add product consultation if found in output
  if (ctx.planOutput) {
    const productSection = extractProductConsultation(ctx.planOutput);
    if (productSection) {
      bodyParts.push(`## Product Review`, "", productSection, "");
    }

    const planSection = extractPlanSummary(ctx.planOutput);
    if (planSection) {
      bodyParts.push(`## Implementation Plan`, "", planSection, "");
    }

    // Always include bounded diagnostics to make escalations actionable.
    const diagnostics = sanitizeDiagnostics(ctx.planOutput).trim();
    if (diagnostics) {
      bodyParts.push(
        `## Diagnostics`,
        "",
        "```",
        diagnostics.slice(0, 20000).trimEnd(),
        "```",
        ""
      );
    }
  }

  // Add resolution placeholder (human writes guidance here)
  bodyParts.push(
    "## Resolution",
    "",
    "<!-- Add human guidance here. Ralph will resume the existing OpenCode session using this text after you set this escalation's status to 'resolved'. -->",
    ""
  );

  // Add action items
  bodyParts.push(
    `## Next Steps`,
    "",
    `1. Review the escalation reason and product context above`,
    `2. Update product documentation if there's a gap`,
    `3. Clarify requirements on the GitHub issue if needed`,
    `4. Add the human guidance under the ## Resolution section above`,
    `5. Mark this escalation note's status as resolved`,
    `6. Ralph will resume the existing OpenCode session using the resolution text (or fall back to a fresh run if resume fails)`,
    "",
    `*Generated by Ralph Loop at ${new Date().toISOString()}*`
  );

  const noteBody = bodyParts.filter(Boolean).join("\n");
  const noteName = sanitizeNoteTitle(`Escalation - ${shortIssue} - ${ctx.taskName.slice(0, 60)}`);

  // Create the agent-escalation note
  // Use taskFileName (the actual filename) for wikilinks, not taskName (display name)
  const escalationPayload = buildEscalationPayload({
    name: noteName,
    task: `[[${resolvedTaskFileName}]]`,
    taskPath: resolvedTaskPath,
    issue: ctx.issue,
    repo: ctx.repo,
    sessionId: ctx.sessionId ?? "",
    escalationType: ctx.escalationType,
    status: "pending",
    creationDate: today,
    scope: "builder",
  });

  const output = await createBwrbNote({
    type: "agent-escalation",
    action: "create escalation",
    payload: escalationPayload,
    allowDuplicateSuffix: true,
  });

  if (output.ok && output.path) {
    const bodyResult = await appendBwrbNoteBody({ notePath: output.path, body: noteBody });
    if (!bodyResult.ok) {
      const log = bodyResult.skipped ? console.warn : console.error;
      log(`[ralph:notify] Failed to write escalation body: ${bodyResult.error}`);
      return false;
    }

    console.log(`[ralph:notify] Created escalation: ${noteName}`);

    try {
      recordIdempotencyKey({
        key: idempotencyKey,
        scope: "notifyEscalation",
        payloadJson: JSON.stringify({ escalationPath: output.path, taskPath: resolvedTaskPath, sessionId: ctx.sessionId ?? "" }),
      });
    } catch {
      // best-effort
    }

    // Send desktop notification
    const issueUrl = ctx.issue.includes("github.com")
      ? ctx.issue
      : `https://github.com/${ctx.issue.replace("#", "/issues/")}`;

    await sendDesktopNotification({
      title: "Ralph: Escalation",
      subtitle: ctx.escalationType,
      message: `${shortIssue} needs attention: ${ctx.reason.slice(0, 100)}`,
      openUrl: issueUrl,
      sound: "Ping",
    });

    return true;
  }

  const error = output.ok ? "bwrb did not return a note path" : output.error;
  const log = !output.ok && output.skipped ? console.warn : console.error;
  log(`[ralph:notify] Failed to create escalation: ${error}`);
  return false;
}

export async function notifyRollupReady(repo: string, prUrl: string, mergedPRs: string[]): Promise<void> {
  const prNumberMatch = prUrl.match(/\/pull\/(\d+)(?:$|\?)/);
  const prNumber = prNumberMatch ? Number(prNumberMatch[1]) : null;

  try {
    await recordRollupReadyAlert({
      repo,
      prNumber: prNumber && Number.isFinite(prNumber) ? prNumber : null,
      prUrl,
      mergedPRs,
    });
  } catch (error: any) {
    console.warn(`[ralph:notify] Failed to record rollup-ready alert for ${repo}: ${error?.message ?? String(error)}`);
  }

  if (!prNumber || !Number.isFinite(prNumber)) {
    console.warn(`[ralph:notify] Unable to parse rollup PR number from ${prUrl}`);
  }

  const body = [
    `A rollup PR is ready for review in **${repo}**.`,
    "",
    `**Rollup PR:** ${prUrl}`,
    "",
    `**Included PRs (${mergedPRs.length}):**`,
    ...mergedPRs.map((pr) => `- ${pr}`),
    "",
    "Please review and merge to main when ready.",
  ].join("\n");

  await createNotification("rollup-ready", `Rollup for ${repo}`, body);

  await sendDesktopNotification({
    title: "Ralph: Rollup Ready",
    subtitle: repo,
    message: `Rollup PR ready: ${prUrl}`.slice(0, 120),
    openUrl: prUrl,
    sound: "Ping",
  });
}

export async function notifyError(context: string, error: string, input?: ErrorNotificationInput): Promise<void> {
  const normalizedInput: ErrorNotificationContext | undefined =
    typeof input === "string" ? { taskName: input } : input ?? undefined;
  const taskName = normalizedInput?.taskName ?? undefined;
  const issueRaw = normalizedInput?.issue?.trim() ?? "";
  const issueRef = issueRaw ? parseIssueRef(issueRaw, normalizedInput?.repo ?? "") : null;

  if (issueRef) {
    try {
      await recordIssueErrorAlert({
        repo: issueRef.repo,
        issueNumber: issueRef.number,
        taskName: taskName ?? undefined,
        context,
        error,
      });
    } catch (error: any) {
      console.warn(
        `[ralph:notify] Failed to record alert for ${issueRef.repo}#${issueRef.number}: ${error?.message ?? String(error)}`
      );
    }
  } else if (normalizedInput?.repo) {
    try {
      recordRepoErrorAlert({
        repo: normalizedInput.repo,
        context,
        error,
      });
    } catch (recordError: any) {
      console.warn(
        `[ralph:notify] Failed to record repo alert for ${normalizedInput.repo}: ${recordError?.message ?? String(recordError)}`
      );
    }
  } else if (normalizedInput?.issue) {
    console.warn(`[ralph:notify] Unable to resolve issue ref for alert (issue=${normalizedInput?.issue ?? ""})`);
  }

  const body = [
    `An error occurred during: **${context}**`,
    "",
    "```",
    error,
    "```",
    "",
    taskName ? `Task: [[${taskName}]]` : "",
  ]
    .filter(Boolean)
    .join("\n");

  await createNotification("error", `Error: ${context}`, body, taskName);

  await sendDesktopNotification({
    title: "Ralph: Error",
    subtitle: taskName ?? "Task Error",
    message: `${context}: ${error.slice(0, 80)}`,
    sound: "Basso",
  });
}

export async function notifyTaskComplete(
  taskName: string,
  repo: string,
  prUrl?: string
): Promise<void> {
  await sendDesktopNotification({
    title: "Ralph: Task Complete",
    subtitle: repo,
    message: `${taskName.slice(0, 60)}${prUrl ? " - PR created" : ""}`,
    openUrl: prUrl,
    sound: "Glass",
  });
}
