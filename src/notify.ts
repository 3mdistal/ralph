import { $ } from "bun";
import { appendFile } from "fs/promises";
import { isAbsolute, join } from "path";
import { loadConfig } from "./config";

export type NotificationType = "escalation" | "rollup-ready" | "error" | "task-complete";

// Cache for terminal-notifier availability check
let terminalNotifierAvailable: boolean | null = null;

/**
 * Check if terminal-notifier is installed on the system.
 * Result is cached for the lifetime of the process.
 */
async function isTerminalNotifierAvailable(): Promise<boolean> {
  if (terminalNotifierAvailable !== null) {
    return terminalNotifierAvailable;
  }

  try {
    await $`which terminal-notifier`.quiet();
    terminalNotifierAvailable = true;
    console.log("[ralph:notify] terminal-notifier is available");
  } catch {
    terminalNotifierAvailable = false;
    console.log("[ralph:notify] terminal-notifier not found, desktop notifications disabled");
  }

  return terminalNotifierAvailable;
}

/**
 * Send a desktop notification using terminal-notifier (macOS).
 * Falls back silently if terminal-notifier is not installed.
 */
export async function sendDesktopNotification(opts: {
  title: string;
  subtitle?: string;
  message: string;
  openUrl?: string;
  sound?: string;
}): Promise<boolean> {
  if (!(await isTerminalNotifierAvailable())) {
    return false;
  }

  try {
    const args: string[] = [
      "-title", opts.title,
      "-message", opts.message,
    ];

    if (opts.subtitle) {
      args.push("-subtitle", opts.subtitle);
    }

    if (opts.openUrl) {
      args.push("-open", opts.openUrl);
    }

    if (opts.sound) {
      args.push("-sound", opts.sound);
    }

    await $`terminal-notifier ${args}`.quiet();
    return true;
  } catch (e) {
    console.warn("[ralph:notify] Failed to send desktop notification:", e);
    return false;
  }
}

function sanitizeNoteTitle(title: string): string {
  return title
    .replace(/[\\/]/g, " - ")
    .replace(/[:*?"<>|]/g, "-")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 180);
}

function getNotificationPrefix(type: NotificationType): string {
  switch (type) {
    case "escalation":
      return "[ESCALATION]";
    case "rollup-ready":
      return "[ROLLUP READY]";
    case "error":
      return "[ERROR]";
    case "task-complete":
      return "[COMPLETE]";
    default:
      return "[RALPH]";
  }
}

function resolveVaultPath(p: string): string {
  const vault = loadConfig().bwrbVault;
  return isAbsolute(p) ? p : join(vault, p);
}

async function bwrbNewIdea(json: string): Promise<{ success: boolean; path?: string; error?: string }> {
  const vault = loadConfig().bwrbVault;
  try {
    const result = await $`bwrb new idea --json ${json}`.cwd(vault).quiet();
    return JSON.parse(result.stdout.toString());
  } catch (e: any) {
    const stdout = e?.stdout?.toString?.() ?? "";
    try {
      return JSON.parse(stdout);
    } catch {
      return { success: false, error: e?.message ?? "Unknown error" };
    }
  }
}

async function bwrbNewEscalation(json: string): Promise<{ success: boolean; path?: string; error?: string }> {
  const vault = loadConfig().bwrbVault;
  try {
    const result = await $`bwrb new agent-escalation --json ${json}`.cwd(vault).quiet();
    return JSON.parse(result.stdout.toString());
  } catch (e: any) {
    const stdout = e?.stdout?.toString?.() ?? "";
    try {
      return JSON.parse(stdout);
    } catch {
      return { success: false, error: e?.message ?? "Unknown error" };
    }
  }
}

/**
 * Create a notification as a bwrb idea note.
 */
export async function createNotification(
  type: NotificationType,
  title: string,
  body: string,
  relatedTask?: string
): Promise<boolean> {
  const today = new Date().toISOString().split("T")[0];
  const prefix = getNotificationPrefix(type);

  const noteBody = [
    `## ${type.replace("-", " ").toUpperCase()}`,
    "",
    body,
    "",
    relatedTask ? `**Related Task:** [[${relatedTask}]]` : "",
    "",
    `*Generated by Ralph Loop at ${new Date().toISOString()}*`,
    "",
  ]
    .filter(Boolean)
    .join("\n");

  const baseTitle = sanitizeNoteTitle(`${prefix} ${title}`);

  let output = await bwrbNewIdea(
    JSON.stringify({
      name: baseTitle,
      "creation-date": today,
      scope: "builder",
    })
  );

  if (!output.success && output.error?.includes("File already exists")) {
    const suffix = crypto.randomUUID().slice(0, 8);
    output = await bwrbNewIdea(
      JSON.stringify({
        name: `${baseTitle} [${suffix}]`,
        "creation-date": today,
        scope: "builder",
      })
    );
  }

  if (output.success && output.path) {
    const notePath = resolveVaultPath(output.path);
    await appendFile(notePath, noteBody, "utf8");
    console.log(`[ralph:notify] Created notification: ${baseTitle}`);
    return true;
  }

  console.error(`[ralph:notify] Failed to create notification:`, output.error ?? "Unknown error");
  return false;
}

export interface EscalationContext {
  /** The display name of the task (from frontmatter `name` field) */
  taskName: string;
  /** The filename without extension (from bwrb `_name` field) - used for wikilinks */
  taskFileName: string;
  /** The full path to the task note (from bwrb `_path` field) */
  taskPath: string;
  issue: string;
  repo: string;
  reason: string;
  escalationType: "product-gap" | "low-confidence" | "ambiguous-requirements" | "blocked" | "other";
  planOutput?: string;
  routing?: {
    decision: string;
    confidence?: string;
    escalation_reason?: string;
    plan_summary?: string;
  };
}

/**
 * Extract the @product consultation section from agent output.
 * Looks for patterns like "**Product context (@product)**" followed by content.
 */
function extractProductConsultation(output: string): string | null {
  // Look for product agent output patterns - capture until next ## heading or end
  const patterns = [
    // ## Product Review section
    /## Product Review\s*\n([\s\S]*?)(?=\n##|$)/i,
    // **Product context (@product)** followed by content until next ## or routing decision
    /\*\*Product[^*]*\*\*[:\s]*([\s\S]*?)(?=\n##|\n\*\*Routing|\{"decision"|$)/i,
    // @product subagent output
    /@product[^:]*:\s*([\s\S]*?)(?=\n##|\n@|$)/i,
  ];

  for (const pattern of patterns) {
    const match = output.match(pattern);
    if (match && match[1]?.trim()) {
      return match[1].trim();
    }
  }
  return null;
}

/**
 * Extract implementation plan summary from agent output.
 */
function extractPlanSummary(output: string): string | null {
  const patterns = [
    // ## Implementation Plan section - capture content after heading
    /## Implementation Plan\s*\n([\s\S]*?)(?=\n##|$)/i,
    // ## Plan section
    /## Plan\s*\n([\s\S]*?)(?=\n##|$)/i,
    // **Plan** inline format
    /\*\*Plan[^*]*\*\*[:\s]*([\s\S]*?)(?=\n##|\n\*\*Routing|\{"decision"|$)/i,
  ];

  for (const pattern of patterns) {
    const match = output.match(pattern);
    if (match && match[1]?.trim()) {
      return match[1].trim();
    }
  }
  return null;
}

export async function notifyEscalation(ctx: EscalationContext): Promise<boolean> {
  const today = new Date().toISOString().split("T")[0];
  const shortIssue = ctx.issue.split("/").pop() || ctx.issue;

  // Build the note body with rich context
  const bodyParts: string[] = [
    `## Escalation Summary`,
    "",
    `Task **${ctx.taskName}** requires your attention.`,
    "",
    `| Field | Value |`,
    `|-------|-------|`,
    `| Issue | ${ctx.issue} |`,
    `| Repo | ${ctx.repo} |`,
    `| Type | ${ctx.escalationType} |`,
    `| Reason | ${ctx.reason} |`,
    "",
  ];

  // Add routing decision if available
  if (ctx.routing) {
    bodyParts.push(
      `## Routing Decision`,
      "",
      `- **Decision:** ${ctx.routing.decision}`,
      ctx.routing.confidence ? `- **Confidence:** ${ctx.routing.confidence}` : "",
      ctx.routing.plan_summary ? `- **Plan Summary:** ${ctx.routing.plan_summary}` : "",
      ""
    );
  }

  // Add product consultation if found in output
  if (ctx.planOutput) {
    console.log(`[ralph:notify] planOutput length: ${ctx.planOutput.length} chars`);
    
    const productSection = extractProductConsultation(ctx.planOutput);
    console.log(`[ralph:notify] productSection extracted: ${productSection ? productSection.length + ' chars' : 'null'}`);
    if (productSection) {
      bodyParts.push(`## Product Review`, "", productSection, "");
    }

    const planSection = extractPlanSummary(ctx.planOutput);
    console.log(`[ralph:notify] planSection extracted: ${planSection ? planSection.length + ' chars' : 'null'}`);
    if (planSection) {
      bodyParts.push(`## Implementation Plan`, "", planSection, "");
    }
  } else {
    console.log(`[ralph:notify] No planOutput provided`);
  }

  // Add action items
  bodyParts.push(
    `## Next Steps`,
    "",
    `1. Review the escalation reason and product context above`,
    `2. Update product documentation if there's a gap`,
    `3. Clarify requirements on the GitHub issue if needed`,
    `4. Re-queue the task once resolved:`,
    "   ```bash",
    `   bwrb edit "${ctx.taskPath}" --json '{"status": "queued"}'`,
    "   ```",
    "",
    `*Generated by Ralph Loop at ${new Date().toISOString()}*`
  );

  const noteBody = bodyParts.filter(Boolean).join("\n");
  const noteName = sanitizeNoteTitle(`Escalation - ${shortIssue} - ${ctx.taskName.slice(0, 60)}`);

  // Create the agent-escalation note
  // Use taskFileName (the actual filename) for wikilinks, not taskName (display name)
  let output = await bwrbNewEscalation(
    JSON.stringify({
      name: noteName,
      task: `[[${ctx.taskFileName}]]`,
      issue: ctx.issue,
      repo: ctx.repo,
      "escalation-type": ctx.escalationType,
      status: "pending",
      "creation-date": today,
      scope: "builder",
    })
  );

  // Handle duplicate names
  if (!output.success && output.error?.includes("File already exists")) {
    const suffix = crypto.randomUUID().slice(0, 8);
    output = await bwrbNewEscalation(
      JSON.stringify({
        name: `${noteName} [${suffix}]`,
        task: `[[${ctx.taskFileName}]]`,
        issue: ctx.issue,
        repo: ctx.repo,
        "escalation-type": ctx.escalationType,
        status: "pending",
        "creation-date": today,
        scope: "builder",
      })
    );
  }

  if (output.success && output.path) {
    const notePath = resolveVaultPath(output.path);
    await appendFile(notePath, noteBody, "utf8");
    console.log(`[ralph:notify] Created escalation: ${noteName}`);

    // Send desktop notification
    const issueUrl = ctx.issue.includes("github.com")
      ? ctx.issue
      : `https://github.com/${ctx.issue.replace("#", "/issues/")}`;

    await sendDesktopNotification({
      title: "Ralph: Escalation",
      subtitle: ctx.escalationType,
      message: `${shortIssue} needs attention: ${ctx.reason.slice(0, 100)}`,
      openUrl: issueUrl,
      sound: "Ping",
    });

    return true;
  }

  console.error(`[ralph:notify] Failed to create escalation:`, output.error ?? "Unknown error");
  return false;
}

export async function notifyRollupReady(repo: string, prUrl: string, mergedPRs: string[]): Promise<void> {
  const body = [
    `A rollup PR is ready for review in **${repo}**.`,
    "",
    `**Rollup PR:** ${prUrl}`,
    "",
    `**Included PRs (${mergedPRs.length}):**`,
    ...mergedPRs.map((pr) => `- ${pr}`),
    "",
    "Please review and merge to main when ready.",
  ].join("\n");

  await createNotification("rollup-ready", `Rollup for ${repo}`, body);
}

export async function notifyError(context: string, error: string, taskName?: string): Promise<void> {
  const body = [
    `An error occurred during: **${context}**`,
    "",
    "```",
    error,
    "```",
    "",
    taskName ? `Task: [[${taskName}]]` : "",
  ]
    .filter(Boolean)
    .join("\n");

  await createNotification("error", `Error: ${context}`, body, taskName);

  // Send desktop notification
  await sendDesktopNotification({
    title: "Ralph: Error",
    subtitle: taskName ?? "Task Error",
    message: `${context}: ${error.slice(0, 80)}`,
    sound: "Basso",
  });
}

export async function notifyTaskComplete(
  taskName: string,
  repo: string,
  prUrl?: string
): Promise<void> {
  await sendDesktopNotification({
    title: "Ralph: Task Complete",
    subtitle: repo,
    message: `${taskName.slice(0, 60)}${prUrl ? " - PR created" : ""}`,
    openUrl: prUrl,
    sound: "Glass",
  });
}
