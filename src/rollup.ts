import { $ } from "bun";
import { loadConfig, getRepoPath, getRepoBotBranch, getRepoRollupBatchSize } from "./config";
import { ensureGhTokenEnv } from "./github-app-auth";
import { notifyRollupReady, notifyError } from "./notify";
import { shouldLog } from "./logging";

export class RollupMonitor {
  private mergeCount: Map<string, number> = new Map();
  private mergedPRs: Map<string, string[]> = new Map();
  private batchSize: number | null;
  private perRepoBatchSize: Map<string, number> = new Map();
  
  constructor(batchSize?: number) {
    this.batchSize = batchSize ?? null;
  }

  private getBatchSize(repo: string): number {
    const cached = this.perRepoBatchSize.get(repo);
    if (cached) return cached;
    const size = getRepoRollupBatchSize(repo, this.batchSize ?? undefined);
    this.perRepoBatchSize.set(repo, size);
    return size;
  }

  
  /**
   * Record a successful merge to bot/integration
   */
  async recordMerge(repo: string, prUrl: string): Promise<void> {
    const count = (this.mergeCount.get(repo) || 0) + 1;
    this.mergeCount.set(repo, count);
    
    const prs = this.mergedPRs.get(repo) || [];
    prs.push(prUrl);
    this.mergedPRs.set(repo, prs);
    
    const batchSize = this.getBatchSize(repo);
    console.log(`[ralph:rollup] Recorded merge for ${repo}: ${prUrl} (${count}/${batchSize})`);
    
    if (count >= batchSize) {
      await this.createRollupPR(repo);
    }
  }
  
  /**
   * Create a rollup PR from bot/integration to main
   */
  async createRollupPR(repo: string): Promise<string | null> {
    const repoPath = getRepoPath(repo);
    const botBranch = getRepoBotBranch(repo);
    const prs = this.mergedPRs.get(repo) || [];
    
    console.log(`[ralph:rollup] Creating rollup PR for ${repo}...`);
    
    try {
      const existing = await this.getOpenRollupPR(repo, botBranch);
      if (existing) {
        if (shouldLog(`rollup:dedupe:${repo}`, 5 * 60_000)) {
          console.log(`[ralph:rollup] Rollup PR already open for ${repo}: ${existing}`);
        }
        return existing;
      }

      const needsRollup = await this.needsRollup(repo, botBranch, repoPath);
      if (!needsRollup) {
        if (shouldLog(`rollup:clean:${repo}`, 5 * 60_000)) {
          console.log(`[ralph:rollup] No differences to roll up for ${repo}`);
        }
        return null;
      }

      // Build PR body
      const today = new Date().toISOString().split("T")[0];
      const prList = prs.map(pr => `- ${pr}`).join("\n");
      const includedSection = prList
        ? prList
        : "(Merged PR list unavailable; no merge history recorded in this session.)";
      
      const body = `## Rollup: ${today} batch

This PR consolidates ${prs.length} changes from the \`${botBranch}\` branch.

### Included PRs

${includedSection}

### Testing

Please test the following areas affected by these changes:
- Run the full test suite: \`bun test\`
- Manually verify any UI changes
- Check for regressions in core functionality

### Review Notes

This is an automated rollup created by Ralph Loop. Each individual PR was reviewed by @product and @devex agents before merging to \`${botBranch}\`.

---
*Generated by Ralph Loop at ${new Date().toISOString()}*`;
      
      // Create the PR
      await ensureGhTokenEnv();
      const result = await $`gh pr create --repo ${repo} --base main --head ${botBranch} --title "Rollup: ${today} batch (${prs.length} PRs)" --body ${body}`.cwd(repoPath).quiet();
      
      const prUrl = result.stdout.toString().trim();
      console.log(`[ralph:rollup] Created rollup PR: ${prUrl}`);
      
      // Reset counts
      this.mergeCount.set(repo, 0);
      this.mergedPRs.set(repo, []);
      
      // Notify
      await notifyRollupReady(repo, prUrl, prs);
      
      return prUrl;
      
    } catch (e: any) {
      console.error(`[ralph:rollup] Failed to create rollup PR:`, e);
      await notifyError(`Creating rollup PR for ${repo}`, e.message);
      return null;
    }
  }

  private async getOpenRollupPR(repo: string, botBranch: string): Promise<string | null> {
    const repoPath = getRepoPath(repo);
    try {
      await ensureGhTokenEnv();
      const result = await $`gh pr list --repo ${repo} --base main --head ${botBranch} --state open --json url`.cwd(repoPath).quiet();
      const raw = result.stdout.toString().trim();
      if (!raw) return null;
      const parsed = JSON.parse(raw) as Array<{ url?: string }>;
      return parsed[0]?.url ?? null;
    } catch (e: any) {
      console.error(`[ralph:rollup] Failed to check existing rollup PR for ${repo}:`, e);
      await notifyError(`Checking existing rollup PR for ${repo}`, e.message);
      return null;
    }
  }
  
  /**
   * Force a rollup for a specific repo (manual trigger)
   */
  async forceRollup(repo: string): Promise<string | null> {
    const count = this.mergeCount.get(repo) || 0;
    if (count === 0) {
      console.log(`[ralph:rollup] No merges to roll up for ${repo}`);
      return null;
    }
    
    return this.createRollupPR(repo);
  }

  async checkIdleRollup(repo: string): Promise<string | null> {
    return this.createRollupPR(repo);
  }

  private async needsRollup(repo: string, botBranch: string, repoPath: string): Promise<boolean> {
    try {
      await $`git fetch --quiet --all`.cwd(repoPath).quiet();
      const result = await $`git rev-list --count main..${botBranch}`.cwd(repoPath).quiet();
      const raw = result.stdout.toString().trim();
      const count = Number.parseInt(raw, 10);
      if (!Number.isFinite(count)) return true;
      return count > 0;
    } catch (e: any) {
      console.error(`[ralph:rollup] Failed to compare ${botBranch} vs main for ${repo}:`, e);
      await notifyError(`Comparing ${botBranch} vs main for ${repo}`, e.message);
      return true;
    }
  }
  
  /**
   * Get current status
   */
  getStatus(): Map<string, { count: number; prs: string[] }> {
    const status = new Map<string, { count: number; prs: string[] }>();
    
    for (const [repo, count] of this.mergeCount) {
      status.set(repo, {
        count,
        prs: this.mergedPRs.get(repo) || [],
      });
    }
    
    return status;
  }
}
