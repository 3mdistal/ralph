{"schemaVersion":1,"domain":"gates","id":"branches.bot-rollup","surface":"git","path":"branches","claim":"Ralph-generated PRs target `bot/integration`; human review happens via rollup PRs to `main`.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.apply-to-bot-branch","surface":"policy","path":"merge/bot","claim":"Deterministic gates are required before merging to `bot/integration`; rollup PR to `main` is the primary human review surface.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"orchestration","id":"principle.minimize-interrupts","surface":"product","path":"principles","claim":"Ralph minimizes human interrupt surface: proceed autonomously and escalate only when human intervention is required.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"queue.github-first","surface":"github","path":"issues","claim":"GitHub Issues + comments are the operator UX and source of truth for queue membership.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"routing.json-decision","surface":"text","path":"docs/escalation-policy.md#routing-decision","claim":"Agents output a routing decision as machine-parseable JSON with keys decision, confidence, and escalation_reason.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config","surface":"filesystem","path":"$HOME/.ralph/opencode","claim":"Ralph daemon runs ignore repo-local OpenCode config and use a Ralph-managed config dir (`$HOME/.ralph/opencode`) unless explicitly overridden.","status":"implemented","source":"docs/ops/opencode-managed-config.md"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config.precedence","surface":"process","path":"OPENCODE_CONFIG_DIR","claim":"Managed OpenCode config precedence is: `RALPH_OPENCODE_CONFIG_DIR` (env) > `opencode.managedConfigDir` (config) > default; Ralph ignores any pre-set `OPENCODE_CONFIG_DIR`.","status":"implemented","source":"docs/ops/opencode-managed-config.md"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config.marker-safety","surface":"filesystem","path":".ralph-managed-opencode","claim":"Ralph refuses to overwrite a non-managed OpenCode config directory unless it contains the `.ralph-managed-opencode` marker (required for paths outside `$HOME`, and for existing directories that don't look like a managed config).","status":"implemented","source":"src/opencode-managed-config.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config.overwrite-templates","surface":"process","path":"managed-config","claim":"Ralph overwrites managed OpenCode config files on startup to match the version shipped with Ralph (minimal opencode.json + agent templates).","status":"implemented","source":"src/opencode-managed-config.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config.lock","surface":"filesystem","path":".ralph-managed-opencode.lock","claim":"Managed OpenCode config writes are guarded by a lock file to avoid concurrent overwrites.","status":"implemented","source":"src/opencode-managed-config.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.xdg-cache.isolated","surface":"process","path":"XDG_CACHE_HOME","claim":"OpenCode runs use an isolated `XDG_CACHE_HOME` under `$HOME/.cache/ralph-opencode/<repo>/<cacheKey>` (or an override) to avoid cross-run cache contention.","status":"implemented","source":"src/session.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.xdg-config.isolated","surface":"process","path":"XDG_CONFIG_HOME","claim":"In daemon runs, Ralph sets an isolated `XDG_CONFIG_HOME` by default (under the per-run OpenCode cache dir) so global user config changes do not leak into Ralph runs. This isolation must not break OpenAI OAuth usage.","status":"implemented","source":"src/session.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.profile-scoped-xdg","surface":"process","path":"XDG_DATA_HOME|XDG_STATE_HOME|XDG_CACHE_HOME","claim":"When OpenCode profiles are enabled and a profile resolves for a task, Ralph launches OpenCode sessions with that profile's XDG dirs (`data/state/cache`) while keeping managed OpenCode config semantics shared across profiles.","status":"implemented","source":"src/worker/opencode-profiles.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.profiles.fail-closed-no-ambient-fallback","surface":"process","path":"profile-resolution","claim":"When OpenCode profiles are enabled, task start/resume must fail closed if no configured profile resolves; Ralph must not silently fall back to ambient XDG/profile context.","status":"implemented","source":"src/worker/opencode-profiles.ts"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config.shared-across-profiles","surface":"process","path":"OPENCODE_CONFIG_DIR","claim":"Ralph uses one shared Ralph-managed OpenCode config surface across all selected profiles; profile selection must not switch config templates or tool definitions.","status":"implemented","source":"src/session.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.cmd-surface","surface":"github","path":"labels/ralph:cmd:*","claim":"Operator intent is expressed via `ralph:cmd:*` labels and normal GitHub comments; commands are processed idempotently and removed.","status":"implemented","source":"src/github/cmd-processor.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.no-touch-non-ralph","surface":"github","path":"labels","claim":"Ralph never edits non-`ralph:*` labels.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.single-status","surface":"github","path":"labels/ralph:status:*","claim":"Ralph never intentionally sets multiple `ralph:status:*` labels; on any successful reconciliation pass it enforces exactly one status label. Temporary drift due to partial GitHub write failures is tolerated but must converge.","status":"implemented","source":"src/github-queue/core.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"watchdog.never-silent-stall","surface":"process","path":"watchdog","claim":"In daemon mode, Ralph must never silently stall on a hung tool call; it uses a soft timeout heartbeat and a hard timeout that kills the run, re-queues once with cleared session id, then escalates if it repeats.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"diagnostics.redaction-local-only","surface":"policy","path":"diagnostics","claim":"Crash diagnostics may include a bounded, redacted log tail; redact obvious tokens and home-directory paths, and do not post logs externally without manual review.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"product-gap.markers.regex","surface":"text","path":"docs/escalation-policy.md#product-gap-markers","claim":"Product gaps are asserted only via explicit line-start markers `PRODUCT GAP:` / `NO PRODUCT GAP:` matched deterministically (example regex: `^\\s*(?:[-*]\\s+)?(NO\\s+)?PRODUCT\\s+GAP:\\s+`).","status":"implemented","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"product-gap.marker-precedence","surface":"policy","path":"docs/escalation-policy.md#product-gap-markers","claim":"Marker precedence: (1) `NO PRODUCT GAP:` negates product-gap assertions even if `PRODUCT GAP:` appears elsewhere; (2) if a product-gap marker is present, it overrides routing JSON and forces escalation.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalate.only-when-needs-human","surface":"policy","path":"docs/escalation-policy.md#when-to-escalate","claim":"Ralph escalates only when it cannot make forward progress without human intervention. Default: attempt at least one bounded self-heal/retry before escalating, except for explicit product-gap markers and non-retriable policy/permission blocks.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalate.contract-surface","surface":"policy","path":"docs/escalation-policy.md#contract-surface","claim":"Contract-surface questions use a hybrid policy: proceed when a change can be made additive and low-complexity; escalate when it would require a breaking change or would add unreasonable compatibility complexity.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalation.low-confidence-not-enough","surface":"policy","path":"docs/escalation-policy.md#low-confidence","claim":"Low confidence alone must not trigger escalation for routine tasks.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalation.resolution.cmd-queue","surface":"github","path":"labels/ralph:cmd:queue","claim":"Escalation resolution: operator replies normally, then applies `ralph:cmd:queue` to resume.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.persist.sqlite","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Gate state and bounded/redacted artifacts are persisted in `~/.ralph/state.sqlite` so gates are deterministic across restarts.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.query.cli","surface":"cli","path":"ralph gates","claim":"Ralph exposes `ralph gates <repo> <issueNumber> [--json]` to query the latest persisted gate state and artifacts.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"preflight.configured-command","surface":"policy","path":"preflight","claim":"Local preflight is required by default; the preflight command comes from a repo-level configuration surface (not ad-hoc per agent) and the run record stores the exact command executed.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"review.marker.contract","surface":"opencode","path":"markers/RALPH_REVIEW","claim":"Review agents must end with exactly one machine-parseable marker `RALPH_REVIEW: {\"status\":\"pass\"|\"fail\",\"reason\":\"...\"}`; missing marker is treated as fail.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci.required-checks","surface":"github","path":"checks","claim":"CI gate is required by default; Ralph awaits required checks after PR open and maps ci status to GitHub check states (success/failure/pending).","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci.fail-triage","surface":"process","path":"ci/triage","claim":"On CI failure, Ralph triages (extract minimal excerpts, classify likely cause) and decides resume vs spawn vs quarantine; it does not blindly retry by default.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci-debug.lane","surface":"process","path":"ci-debug","claim":"If an issue has an open PR with failing/timed-out required checks, Ralph runs a CI-debug lane: comment once (edit, no duplicates), spawn dedicated debug run (fresh worktree/session), bounded retries (configurable via `RALPH_CI_REMEDIATION_MAX_ATTEMPTS`; default 5), then escalate if still failing.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"merge-conflict.lane","surface":"process","path":"merge-conflict","claim":"If an issue has an open PR with mergeStateStatus=DIRTY, Ralph runs a merge-conflict recovery lane: comment once (edit, no duplicates), spawn dedicated recovery run (fresh worktree/session), merge base into head (no rebase/no force), run tests/typecheck/build/knip, bounded retries (configurable via `RALPH_MERGE_CONFLICT_MAX_ATTEMPTS`; default 2), then escalate if still DIRTY.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"plan.product-review.required","surface":"opencode","path":"markers/RALPH_PLAN_REVIEW","claim":"Plan stage requires a product review gate for every task. The final line of the product plan-review agent response must include exactly one machine-parseable marker: `RALPH_PLAN_REVIEW: {\"status\":\"pass\"|\"fail\",\"reason\":\"...\"}`. Missing marker is treated as fail. If the failure is due to missing product guidance, the agent also emits a single `PRODUCT GAP:` marker (per `docs/escalation-policy.md`).","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gate-record.required-fields","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Persisted gate records include required fields: `preflight.status`, `preflight.command` (required unless preflight is skipped), `plan_review.status`, `product_review.status`, `devex_review.status`, `ci.status`, `pr_evidence.status`, and derived `ready_for_pr`.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"completion.pr-evidence-required","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Issue-linked implementation runs may be recorded as `outcome=success` only when persisted PR evidence exists (`pr_evidence.status=pass` with `pr_url` and `pr_number`), except explicit no-PR terminal reasons defined by policy (for example `completionKind=verified`).","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.artifacts.redaction-bounds","surface":"policy","path":"gate-artifacts","claim":"Persisted gate artifacts are deterministically bounded and redacted (tokens/paths/secrets) before storage or operator surfacing.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.restart.replay-deterministic","surface":"process","path":"gates/restart-recovery","claim":"Across daemon restarts/recovery, deterministic gate transitions must not be duplicated or skipped; replay is idempotent from persisted gate state.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.ci.classifier.versioned","surface":"process","path":"ci/triage","claim":"CI failure triage persists a versioned classifier payload so decision semantics are auditable and migration-safe.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"orchestration","id":"pr-create.owner.orchestrator-only","surface":"process","path":"lanes/pr-recovery","claim":"PR creation is orchestrator-owned: Ralph (not build agents) is the only writer allowed to run `gh pr create` in automation lanes.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"pr-create.agent-contract.branch-evidence","surface":"opencode","path":"build-contract","claim":"Build-agent completion contract for issue-linked implementation is branch evidence (`branch`, `head_sha`, test/preflight summary, ready_for_pr_create flag), not a PR URL.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"completion.no-success-without-pr-or-terminal-reason","surface":"process","path":"completion/invariants","claim":"Issue-linked implementation must never end as success without either PR evidence or an explicit allowed no-PR terminal reason.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"gates","id":"retry-budgets.per-lane-configurable","surface":"policy","path":"retries","claim":"Retry budgets for remediation lanes are bounded and configurable per lane via env (`RALPH_CI_REMEDIATION_MAX_ATTEMPTS`, `RALPH_MERGE_CONFLICT_MAX_ATTEMPTS`); defaults are 5 and 2 respectively.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.forward-only","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"`~/.ralph/state.sqlite` migrations are forward-only on startup. Forward-newer state within the readable window (`schemaVersion > maxWritableSchema && schemaVersion <= maxReadableSchema`) is readable in read-only mode; Ralph fails closed only when `schemaVersion > maxReadableSchema`.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.migrations.transactional","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"SQLite migrations run inside a single transaction; partial migrations must not be observable.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.schema-version.bump","surface":"repo","path":"src/state.ts","claim":"Each schema change bumps `SCHEMA_VERSION` in `src/state.ts`.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.no-downgrades","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"No downgrades: Ralph never migrates durable state backwards. When `meta.schema_version` is newer than the binary's writable window, writes are blocked; if it exceeds the readable window (`maxReadableSchema`), Ralph fails closed and operators recover by upgrading first or restoring a compatible backup.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.backup-before-mutate","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Before any schema/invariant mutation, Ralph creates and validates a timestamped SQLite backup snapshot; operator guidance prefers restore-from-backup over deleting state.sqlite.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"state.sqlite-authoritative","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"SQLite under `~/.ralph` stores durable internal state (sessions, worktrees, cursors, run records).","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.two-tier","surface":"process","path":"policy","claim":"Usage throttling is a daemon-level policy; hard throttle stops all model sends and soft throttle stops starting new tasks.","status":"implemented","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.openai.remote-first","surface":"process","path":"throttle.openaiSource","claim":"OpenAI usage is remote-first: use remote usage meters by default and fall back to local OpenCode logs only if remote usage is unavailable or fails.","status":"planned","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.hard-is-must","surface":"policy","path":"throttle/hard","claim":"Hard throttle is the must-enforce safety boundary; soft throttle is best-effort and secondary.","status":"planned","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"github","id":"github.rate-limit.backoff-and-caching","surface":"github","path":"api","claim":"Ralph respects GitHub backoff signals (honor Retry-After when present; otherwise exponential backoff with jitter on rate limiting/abuse detection) and reduces pressure via caching safe GETs and coalescing label writes.","status":"planned","source":"docs/ops/github-rate-limiting.md"}
{"schemaVersion":1,"domain":"dashboard","id":"dashboard.auth.bearer-required","surface":"http","path":"/v1/*","claim":"Control plane endpoints require `Authorization: Bearer <token>`.","status":"planned","source":"docs/archive/product/dashboard-mvp-control-plane-tui.md"}
{"schemaVersion":1,"domain":"dashboard","id":"dashboard.bind.local-default","surface":"http","path":"bind","claim":"Control plane binds to 127.0.0.1 by default; non-loopback binds require an explicit allowRemote setting.","status":"planned","source":"docs/archive/product/dashboard-mvp-control-plane-tui.md"}
{"schemaVersion":1,"domain":"dashboard","id":"dashboard.state.additive-only","surface":"http","path":"/v1/state","claim":"`/v1/state` is additive-only in v1: new fields may be added, but existing fields must not be removed or change type.","status":"planned","source":"docs/archive/product/dashboard-mvp-control-plane-tui.md"}
{"schemaVersion":1,"domain":"dashboard","id":"dashboard.redaction.tokens-paths","surface":"http","path":"/v1/*","claim":"Control plane output is redacted for obvious tokens and paths.","status":"planned","source":"docs/archive/product/dashboard-mvp-control-plane-tui.md"}

{"schemaVersion":1,"domain":"orchestration","id":"queue.single-daemon","surface":"process","path":"daemon","claim":"Single daemon per queue is required until claiming semantics are transactional.","status":"planned","source":"docs/archive/product/github-first-orchestration.md"}
{"schemaVersion":1,"domain":"orchestration","id":"deps.github-native-only","surface":"github","path":"issues/relationships","claim":"Dependency graph source of truth is GitHub-native relationships only; do not parse issue bodies for dependencies.","status":"planned","source":"docs/archive/product/github-first-orchestration.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.satisfy.no-status-change","surface":"github","path":"labels/ralph:cmd:satisfy","claim":"`ralph:cmd:satisfy` records dependency satisfaction only and does not change the issue status label.","status":"implemented","source":"src/github/cmd-processor.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"parent-verification.mandatory","surface":"process","path":"lanes/parent-verification","claim":"When a parent becomes unblocked, Ralph attempts the parent verification lane before starting full implementation. If verification fails or is inconclusive after bounded attempts, proceed to implementation but seed the run with child-issue evidence context.","status":"planned","source":"docs/product/parent-verification-lane.md"}
{"schemaVersion":1,"domain":"orchestration","id":"parent-verification.close-hybrid","surface":"policy","path":"lanes/parent-verification","claim":"If parent verification determines `work_remains=false`, Ralph may complete without a PR by posting/updating a single structured verification comment and then setting `ralph:status:done` + closing the issue when confidence/evidence are strong; otherwise it escalates with a 'close or clarify' summary.","status":"planned","source":"docs/product/parent-verification-lane.md"}
{"schemaVersion":1,"domain":"orchestration","id":"parent-verify.marker","surface":"opencode","path":"markers/RALPH_PARENT_VERIFY","claim":"The parent verification agent emits a last-line marker `RALPH_PARENT_VERIFY: {\"version\":1,\"work_remains\":true|false,\"reason\":\"...\"}` and may include additional keys (e.g. confidence, evidence).","status":"implemented","source":"docs/product/parent-verification-lane.md"}
{"schemaVersion":1,"domain":"orchestration","id":"priority.labels.set","surface":"github","path":"labels/ralph:priority:*","claim":"Priority is expressed via `ralph:priority:p0`..`ralph:priority:p4` labels; default is `p2` when absent.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"priority.queue-order-only","surface":"process","path":"scheduler","claim":"Priority labels affect dequeue order among `ralph:status:queued` only; they do not change status or imply queueing.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"workerid.not-repo","surface":"process","path":"workerId","claim":"Worker identity must not be repo name; workerId must remain stable for concurrency and operator observability.","status":"planned","source":"docs/archive/product/dashboard-mvp-control-plane-tui.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalation.bias-proceed","surface":"policy","path":"routing","claim":"Escalation sensitivity is driven only by `ralph:*` labels plus deterministic markers and contract-surface detection; ignore non-`ralph:*` labels.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.isolated-execution","surface":"filesystem","path":"~/.ralph/worktrees","claim":"Task work executes in isolated git worktrees (not in the main checkout).","status":"implemented","source":"docs/product/worktree-management.md"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.dir.default","surface":"filesystem","path":"~/.ralph/worktrees","claim":"Default managed worktree root is `~/.ralph/worktrees`.","status":"implemented","source":"src/paths.ts"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.dir.override-env","surface":"process","path":"RALPH_WORKTREES_DIR","claim":"Worktree root can be overridden via `RALPH_WORKTREES_DIR` (absolute or relative to current working directory).","status":"implemented","source":"src/paths.ts"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.layout","surface":"filesystem","path":"~/.ralph/worktrees/<repoKey>/slot-<slot>/<issueNumber>/<taskKey>","claim":"Managed worktree layout is `~/.ralph/worktrees/<repoKey>/slot-<slot>/<issueNumber>/<taskKey>`.","status":"implemented","source":"src/worktree-paths.ts"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.never-run-in-repo-root","surface":"process","path":"worktree-path","claim":"Ralph refuses to run a task in the repo root; if recorded `worktree-path` matches repo root, it fails hard.","status":"implemented","source":"src/worker.ts"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.resume.requires-path","surface":"process","path":"worktree-path","claim":"Ralph refuses to resume an in-progress task if `worktree-path` is missing (to avoid running in the main checkout).","status":"implemented","source":"src/worker.ts"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.stale-path.reset","surface":"process","path":"worktree-path","claim":"If a recorded `worktree-path` is missing/invalid, Ralph removes it best-effort and resets the task back to queued with cleared session/worktree metadata.","status":"implemented","source":"src/worker.ts"}
{"schemaVersion":1,"domain":"worktree","id":"legacy.warn-only","surface":"process","path":"legacy-worktrees","claim":"Legacy worktrees outside the managed root are detected and logged as bounded warnings; Ralph does not auto-delete or auto-migrate them by default.","status":"implemented","source":"src/legacy-worktrees.ts"}

{"schemaVersion":1,"domain":"orchestration","id":"cmd.issuer-any-collaborator","surface":"github","path":"labels/ralph:cmd:*","claim":"Any collaborator who can apply labels may issue `ralph:cmd:*` commands.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.queue.async-status-ok","surface":"github","path":"labels/ralph:cmd:queue","claim":"`ralph:cmd:queue` may be processed asynchronously; when it is processed successfully, Ralph ensures `ralph:status:queued` is present and clears stop-switch labels. If GitHub label writes fail, command removal may be delayed until a retry.","status":"implemented","source":"src/github/cmd-processor.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.queue.force-queued","surface":"github","path":"labels/ralph:cmd:queue","claim":"When Ralph processes `ralph:cmd:queue` on an open issue, it must not remove the command label without also ensuring `ralph:status:queued` is present (preferably in the same GitHub label mutation).","status":"implemented","source":"src/github/cmd-processor.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.stop.leaves-pr-open","surface":"github","path":"labels/ralph:cmd:stop","claim":"When `ralph:cmd:stop` is applied, Ralph stops automation and leaves any open PRs open.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.satisfy.deps-only","surface":"github","path":"labels/ralph:cmd:satisfy","claim":"`ralph:cmd:satisfy` records dependency satisfaction only; it does not imply merge or issue closure.","status":"implemented","source":"src/github/cmd-processor.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"degraded-mode.keep-progressing","surface":"process","path":"degraded-mode","claim":"If GitHub label writes are unavailable, Ralph may continue progressing tasks using SQLite truth and reconcile labels later; this does not permit PR-required completion paths to succeed when PR creation writes are blocked.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"done.from-merged-pr-evidence","surface":"github","path":"labels/ralph:status:done","claim":"`ralph:status:done` is derived from either merged PR evidence reconciled onto default branch, or (parent-verification lane only) structured verification-comment evidence for no-PR completion.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"done.evidence.events-plus-git","surface":"github","path":"issues/timeline","claim":"Done evidence chain: use GitHub issue timeline events to identify the closing merged PR, then verify the relevant commit SHA is reachable from the repo default branch head.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.bootstrap.enforce-metadata","surface":"github","path":"labels","claim":"Ralph ensures required `ralph:status:*` and `ralph:cmd:*` labels exist and enforces their label descriptions/colors to match the version shipped with Ralph.","status":"implemented","source":"src/github/ensure-ralph-workflow-labels.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.required.set","surface":"github","path":"labels/required","claim":"Required Ralph labels (names): statuses = [`ralph:status:queued`,`ralph:status:in-progress`,`ralph:status:paused`,`ralph:status:escalated`,`ralph:status:in-bot`,`ralph:status:done`,`ralph:status:stopped`], commands = [`ralph:cmd:queue`,`ralph:cmd:pause`,`ralph:cmd:stop`,`ralph:cmd:satisfy`], priority = [`ralph:priority:p0`,`ralph:priority:p1`,`ralph:priority:p2`,`ralph:priority:p3`,`ralph:priority:p4`].","status":"planned","source":"docs/product/orchestration-contract.md"}

{"schemaVersion":1,"domain":"sandbox","id":"sandbox.repo-private","surface":"github","path":"repos","claim":"Sandbox provisioning creates a fresh private repo per run from a template.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.naming.rule","surface":"github","path":"repos/name","claim":"Sandbox repo name is `${sandbox.repoNamePrefix}${runIdShort}`.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.visibility.private-only","surface":"policy","path":"sandbox.provisioning.repoVisibility","claim":"Sandbox provisioning v1 supports `private` repos only; non-private is a hard error.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.manifest.write","surface":"filesystem","path":"~/.ralph/sandbox/manifests/<runId>.json","claim":"Sandbox provisioning writes a v1 manifest to `~/.ralph/sandbox/manifests/<runId>.json` for auditability and follow-on commands.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.seed.idempotent","surface":"process","path":"sandbox:seed","claim":"Sandbox seeding is deterministic and idempotent by `key`; reruns skip entries already recorded in the manifest.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.minimal.labels","surface":"github","path":"labels","claim":"Sandbox settings preset `minimal` ensures all required `ralph:status:*` and `ralph:cmd:*` labels exist (as defined by `labels.required.set`).","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.minimal.bot-branch","surface":"git","path":"branches","claim":"Sandbox settings preset `minimal` creates the bot branch (e.g. `bot/integration`) from default branch if missing.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.parity.best-effort","surface":"github","path":"settings","claim":"Sandbox settings preset `parity` copies branch protection and rulesets best-effort; permission/API failures become warnings and must not block provisioning.","status":"planned","source":"docs/product/sandbox-provisioning.md"}

{"schemaVersion":1,"domain":"opencode","id":"opencode.bin.resolve","surface":"process","path":"OPENCODE_BIN","claim":"Ralph resolves the OpenCode binary deterministically (`OPENCODE_BIN` override > known absolute candidates like `~/.local/bin/opencode` > PATH fallback) and uses the resolved path for all OpenCode spawns.","status":"implemented","source":"src/session.ts"}

{"schemaVersion":1,"domain":"orchestration","id":"daemon.control-root.canonical","surface":"filesystem","path":"control/daemon registry","claim":"Ralph control-plane artifacts (`daemon.json`, `control.json`, daemon registry) must live under one canonical root independent of selected OpenCode usage profile.","status":"implemented","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"daemon.discovery.profile-agnostic","surface":"cli","path":"ralphctl status|drain|resume","claim":"`ralphctl` daemon discovery is profile-agnostic: it must find and target the live daemon even when the caller's ambient XDG/profile differs from the daemon's worker profile context.","status":"implemented","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"daemon.pid-liveness.required","surface":"process","path":"status/discovery","claim":"Status/control operations validate daemon PID liveness before reporting running state; stale daemon records are auto-healed or clearly flagged as stale.","status":"implemented","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"profiles.selection-not-identity","surface":"process","path":"scheduler/profile-selection","claim":"OpenCode profile selection optimizes model usage capacity per task and must not change daemon identity, control file location, discovery semantics, or behavior/config semantics.","status":"implemented","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"orchestration","id":"daemon.singleton.locked","surface":"process","path":"startup/lock","claim":"Ralph enforces singleton daemon ownership for a canonical control root with a startup lock to prevent concurrent daemons writing conflicting control records.","status":"implemented","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"doctor.discovery-repair","surface":"cli","path":"ralphctl doctor","claim":"Ralph provides a doctor/repair command to reconcile stale daemon/control records across known state roots and restore deterministic control-plane discovery.","status":"implemented","source":"docs/product/orchestration-contract.md"}

{"schemaVersion":1,"domain":"gates","id":"ci-remediation.on-required-checks-failure","surface":"process","path":"lanes/ci-debug","claim":"When an issue has an open PR with failing required checks, Ralph runs a CI remediation lane that attempts to make checks green (bounded retries) and only escalates after exhausting the budget.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"review.repair-on-marker-invalid","surface":"opencode","path":"markers/RALPH_REVIEW","claim":"If a deterministic review gate fails only due to an invalid/missing RALPH_REVIEW marker, Ralph retries the review with a bounded, corrective prompt (or fails with high-signal diagnostics) instead of blocking indefinitely.","status":"implemented","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"github","id":"github.auth.daemon.deterministic","surface":"process","path":"github/auth","claim":"In daemon mode, Ralph GitHub authentication is deterministic and validated early; do not rely on ambient `gh auth login` state. Missing/invalid credentials fail fast with an actionable auth-blocked reason that includes the attempted command and stderr.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"diagnostics.gh-errors.include-command-and-stderr","surface":"policy","path":"diagnostics/gh","claim":"When a gh invocation blocks progress, Ralph includes the redacted gh command plus bounded stderr/stdout excerpts in the blocked reason/details for operator diagnosis.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"claims","id":"claims.canonical.status-in-sync","surface":"process","path":"claims/canonical.jsonl","claim":"Canonical claim statuses remain in sync with shipped behavior: a lightweight unit test asserts select shipped claims are `implemented`, and contributors update claim status alongside relevant code changes.","status":"implemented","source":"claims/README.md"}
{"schemaVersion":1,"domain":"orchestration","id":"orchestration.pr-create.lease.self-heal-no-pr","surface":"sqlite","path":"idempotency/pr-create","claim":"If a PR-create lease conflict persists and no PR appears after bounded wait, Ralph attempts one deterministic self-heal reclaim of the stale/abandoned lease before throttling/escalating.","status":"implemented","source":"src/worker/repo-worker.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"orchestration.pr-create.retry.policy-aware","surface":"process","path":"lanes/start|lanes/resume|pr-recovery","claim":"PR-create retries are policy-aware: permission/policy denials are non-retriable and escalate immediately; transient failures retry with bounded backoff.","status":"implemented","source":"src/worker/pr-create-policy.ts"}
{"schemaVersion":1,"domain":"orchestration","id":"orchestration.pr-create.capability-gate","surface":"github","path":"pr-create/capability","claim":"Before entering PR-required completion flow, Ralph performs a PR-create capability gate and routes missing capability to explicit blocked-policy handling.","status":"implemented","source":"src/worker/repo-worker.ts"}
