{"schemaVersion":1,"domain":"gates","id":"branches.bot-rollup","surface":"git","path":"branches","claim":"Ralph-generated PRs target `bot/integration`; human review happens via rollup PRs to `main`.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.apply-to-bot-branch","surface":"policy","path":"merge/bot","claim":"Deterministic gates are required before merging to `bot/integration`; rollup PR to `main` is the primary human review surface.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"orchestration","id":"principle.minimize-interrupts","surface":"product","path":"principles","claim":"Ralph minimizes human interrupt surface: proceed autonomously and escalate only when human intervention is required.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"queue.github-first","surface":"github","path":"issues","claim":"GitHub Issues + comments are the operator UX and source of truth for queue membership.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"routing.json-decision","surface":"text","path":"docs/escalation-policy.md#routing-decision","claim":"Agents output a routing decision as machine-parseable JSON with keys decision, confidence, and escalation_reason.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"opencode","id":"opencode.managed-config","surface":"filesystem","path":"$HOME/.ralph/opencode","claim":"Ralph daemon runs ignore repo-local OpenCode config and use a Ralph-managed config dir (`$HOME/.ralph/opencode`) unless explicitly overridden.","status":"implemented","source":"docs/ops/opencode-managed-config.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.cmd-surface","surface":"github","path":"labels/ralph:cmd:*","claim":"Operator intent is expressed via `ralph:cmd:*` labels and normal GitHub comments; commands are processed idempotently and removed.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.no-touch-non-ralph","surface":"github","path":"labels","claim":"Ralph never edits non-`ralph:*` labels.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.single-status","surface":"github","path":"labels/ralph:status:*","claim":"Ralph never intentionally sets multiple `ralph:status:*` labels; on any successful reconciliation pass it enforces exactly one status label. Temporary drift due to partial GitHub write failures is tolerated but must converge.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"watchdog.never-silent-stall","surface":"process","path":"watchdog","claim":"In daemon mode, Ralph must never silently stall on a hung tool call; it uses a soft timeout heartbeat and a hard timeout that kills the run, re-queues once with cleared session id, then escalates if it repeats.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"diagnostics.redaction-local-only","surface":"policy","path":"diagnostics","claim":"Crash diagnostics may include a bounded, redacted log tail; redact obvious tokens and home-directory paths, and do not post logs externally without manual review.","status":"planned","source":"docs/product/vision.md"}
{"schemaVersion":1,"domain":"orchestration","id":"product-gap.markers.regex","surface":"text","path":"docs/escalation-policy.md#product-gap-markers","claim":"Product gaps are asserted only via explicit line-start markers `PRODUCT GAP:` / `NO PRODUCT GAP:` matched deterministically (example regex: `^\\s*(?:[-*]\\s+)?(NO\\s+)?PRODUCT\\s+GAP:\\s+`).","status":"implemented","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"product-gap.marker-precedence","surface":"policy","path":"docs/escalation-policy.md#product-gap-markers","claim":"Marker precedence: (1) `NO PRODUCT GAP:` negates product-gap assertions even if `PRODUCT GAP:` appears elsewhere; (2) if a product-gap marker is present, it overrides routing JSON and forces escalation.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalate.only-when-needs-human","surface":"policy","path":"docs/escalation-policy.md#when-to-escalate","claim":"Ralph escalates only when it cannot make forward progress without human intervention. Default: attempt at least one bounded self-heal/retry before escalating, except for explicit product-gap markers.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalate.contract-surface","surface":"policy","path":"docs/escalation-policy.md#contract-surface","claim":"Contract-surface questions use a hybrid policy: proceed when a change can be made additive and low-complexity; escalate when it would require a breaking change or would add unreasonable compatibility complexity.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalation.low-confidence-not-enough","surface":"policy","path":"docs/escalation-policy.md#low-confidence","claim":"Low confidence alone must not trigger escalation for routine tasks.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"orchestration","id":"escalation.resolution.cmd-queue","surface":"github","path":"labels/ralph:cmd:queue","claim":"Escalation resolution: operator replies normally, then applies `ralph:cmd:queue` to resume.","status":"planned","source":"docs/escalation-policy.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.persist.sqlite","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Gate state and bounded/redacted artifacts are persisted in `~/.ralph/state.sqlite` so gates are deterministic across restarts.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gates.query.cli","surface":"cli","path":"ralph gates","claim":"Ralph exposes `ralph gates <repo> <issueNumber> [--json]` to query the latest persisted gate state and artifacts.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"preflight.configured-command","surface":"policy","path":"preflight","claim":"Local preflight is required by default; the preflight command comes from a repo-level configuration surface (not ad-hoc per agent) and the run record stores the exact command executed.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"review.marker.contract","surface":"opencode","path":"markers/RALPH_REVIEW","claim":"Review agents must end with exactly one machine-parseable marker `RALPH_REVIEW: {\"status\":\"pass\"|\"fail\",\"reason\":\"...\"}`; missing marker is treated as fail.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci.required-checks","surface":"github","path":"checks","claim":"CI gate is required by default; Ralph awaits required checks after PR open and maps ci status to GitHub check states (success/failure/pending).","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci.fail-triage","surface":"process","path":"ci/triage","claim":"On CI failure, Ralph triages (extract minimal excerpts, classify likely cause) and decides resume vs spawn vs quarantine; it does not blindly retry by default.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"ci-debug.lane","surface":"process","path":"ci-debug","claim":"If an issue has an open PR with failing/timed-out required checks, Ralph runs a CI-debug lane: comment once (edit, no duplicates), spawn dedicated debug run (fresh worktree/session), bounded retries (2-3), then escalate if still failing.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"merge-conflict.lane","surface":"process","path":"merge-conflict","claim":"If an issue has an open PR with mergeStateStatus=DIRTY, Ralph runs a merge-conflict recovery lane: comment once (edit, no duplicates), spawn dedicated recovery run (fresh worktree/session), merge base into head (no rebase/no force), run tests/typecheck/build/knip, bounded retries (2-3), then escalate if still DIRTY.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"plan.product-review.required","surface":"opencode","path":"markers/RALPH_PLAN_REVIEW","claim":"Plan stage requires a product review gate for every task. The final line of the product plan-review agent response must include exactly one machine-parseable marker: `RALPH_PLAN_REVIEW: {\"status\":\"pass\"|\"fail\",\"reason\":\"...\"}`. Missing marker is treated as fail. If the failure is due to missing product guidance, the agent also emits a single `PRODUCT GAP:` marker (per `docs/escalation-policy.md`).","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"gate-record.required-fields","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"Persisted gate records include required fields: `preflight.status`, `preflight.command` (required unless preflight is skipped), `product_review.status`, `devex_review.status`, `ci.status`, and derived `ready_for_pr`.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"gates","id":"retry-budgets.per-lane-configurable","surface":"policy","path":"retries","claim":"Retry budgets for remediation lanes (e.g. CI-debug, merge-conflict) are bounded and per-lane configurable; defaults are not assumed by policy.","status":"planned","source":"docs/product/deterministic-gates.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.forward-only","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"`~/.ralph/state.sqlite` is forward-only migrated on startup; if schema is newer than the binary expects, Ralph fails closed.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.migrations.transactional","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"SQLite migrations run inside a single transaction; partial migrations must not be observable.","status":"planned","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.schema-version.bump","surface":"repo","path":"src/state.ts","claim":"Each schema change bumps `SCHEMA_VERSION` in `src/state.ts`.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.no-downgrades","surface":"sqlite","path":"~/.ralph/state.sqlite","claim":"No downgrades: if `meta.schema_version` is newer than the running binary, Ralph fails closed.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"state","id":"sqlite.safe-reset","surface":"filesystem","path":"~/.ralph/state.sqlite","claim":"Safe reset: deleting `~/.ralph/state.sqlite` recreates a fresh database on next startup.","status":"implemented","source":"docs/ops/state-sqlite.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.two-tier","surface":"process","path":"policy","claim":"Usage throttling is a daemon-level policy; hard throttle stops all model sends and soft throttle stops starting new tasks.","status":"implemented","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.openai.remote-first","surface":"process","path":"throttle.openaiSource","claim":"OpenAI usage is remote-first: use remote usage meters by default and fall back to local OpenCode logs only if remote usage is unavailable or fails.","status":"planned","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"throttle","id":"throttle.hard-is-must","surface":"policy","path":"throttle/hard","claim":"Hard throttle is the must-enforce safety boundary; soft throttle is best-effort and secondary.","status":"planned","source":"docs/product/usage-throttling.md"}
{"schemaVersion":1,"domain":"github","id":"github.rate-limit.backoff-and-caching","surface":"github","path":"api","claim":"Ralph respects GitHub backoff signals (honor Retry-After when present; otherwise exponential backoff with jitter on rate limiting/abuse detection) and reduces pressure via caching safe GETs and coalescing label writes.","status":"planned","source":"docs/ops/github-rate-limiting.md"}
{"schemaVersion":1,"domain":"worktree","id":"worktree.isolated-execution","surface":"filesystem","path":"~/.ralph/worktrees","claim":"Task work executes in isolated git worktrees (not in the main checkout).","status":"implemented","source":"docs/product/worktree-management.md"}

{"schemaVersion":1,"domain":"orchestration","id":"cmd.issuer-any-collaborator","surface":"github","path":"labels/ralph:cmd:*","claim":"Any collaborator who can apply labels may issue `ralph:cmd:*` commands.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.queue.async-status-ok","surface":"github","path":"labels/ralph:cmd:queue","claim":"`ralph:cmd:queue` may be processed asynchronously; status label updates are best-effort and may lag command removal.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.stop.leaves-pr-open","surface":"github","path":"labels/ralph:cmd:stop","claim":"When `ralph:cmd:stop` is applied, Ralph stops automation and leaves any open PRs open.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"cmd.satisfy.deps-only","surface":"github","path":"labels/ralph:cmd:satisfy","claim":"`ralph:cmd:satisfy` records dependency satisfaction only; it does not imply merge or issue closure.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"degraded-mode.keep-progressing","surface":"process","path":"degraded-mode","claim":"If GitHub label writes are unavailable, Ralph may continue progressing tasks using SQLite truth and reconcile labels later.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"done.from-merged-pr-evidence","surface":"github","path":"labels/ralph:status:done","claim":"`ralph:status:done` is derived from merged PR evidence that closes the issue and is reconciled onto the repo default branch.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"done.evidence.events-plus-git","surface":"github","path":"issues/timeline","claim":"Done evidence chain: use GitHub issue timeline events to identify the closing merged PR, then verify the relevant commit SHA is reachable from the repo default branch head.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.bootstrap.enforce-metadata","surface":"github","path":"labels","claim":"Ralph ensures required `ralph:status:*` and `ralph:cmd:*` labels exist and enforces their label descriptions/colors to match the version shipped with Ralph.","status":"planned","source":"docs/product/orchestration-contract.md"}
{"schemaVersion":1,"domain":"orchestration","id":"labels.required.set","surface":"github","path":"labels/required","claim":"Required Ralph labels (names): statuses = [`ralph:status:queued`,`ralph:status:in-progress`,`ralph:status:paused`,`ralph:status:escalated`,`ralph:status:in-bot`,`ralph:status:done`,`ralph:status:stopped`], commands = [`ralph:cmd:queue`,`ralph:cmd:pause`,`ralph:cmd:stop`,`ralph:cmd:satisfy`].","status":"planned","source":"docs/product/orchestration-contract.md"}

{"schemaVersion":1,"domain":"sandbox","id":"sandbox.repo-private","surface":"github","path":"repos","claim":"Sandbox provisioning creates a fresh private repo per run from a template.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.naming.rule","surface":"github","path":"repos/name","claim":"Sandbox repo name is `${sandbox.repoNamePrefix}${runIdShort}`.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.visibility.private-only","surface":"policy","path":"sandbox.provisioning.repoVisibility","claim":"Sandbox provisioning v1 supports `private` repos only; non-private is a hard error.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.manifest.write","surface":"filesystem","path":"~/.ralph/sandbox/manifests/<runId>.json","claim":"Sandbox provisioning writes a v1 manifest to `~/.ralph/sandbox/manifests/<runId>.json` for auditability and follow-on commands.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.seed.idempotent","surface":"process","path":"sandbox:seed","claim":"Sandbox seeding is deterministic and idempotent by `key`; reruns skip entries already recorded in the manifest.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.minimal.labels","surface":"github","path":"labels","claim":"Sandbox settings preset `minimal` ensures all required `ralph:status:*` and `ralph:cmd:*` labels exist (as defined by `labels.required.set`).","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.minimal.bot-branch","surface":"git","path":"branches","claim":"Sandbox settings preset `minimal` creates the bot branch (e.g. `bot/integration`) from default branch if missing.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
{"schemaVersion":1,"domain":"sandbox","id":"sandbox.preset.parity.best-effort","surface":"github","path":"settings","claim":"Sandbox settings preset `parity` copies branch protection and rulesets best-effort; permission/API failures become warnings and must not block provisioning.","status":"planned","source":"docs/product/sandbox-provisioning.md"}
